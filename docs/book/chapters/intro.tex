\chapter{Introduction}

Welcome to this journey of writing an operating system kernel from scratch... and, with some optimism, not going insane in the 
process. This book encourages you to explore how kernels work, help you learn from my experience, and 
perhaps even avoid some of my mistakes. 

When I started studying operating systems, I found very few resources, most of which warned that
OS development is so challenging a subject that should be avoided by anyone lacking extensive experience
in low-level systems programming. Being the optimist I am, I ignored the warnings and dove in, only to discover 
that they were, well… pretty much right.

However, the majority of obstacles I have encountered stem directly from a lack of resources.
It is unclear whether this scarcity arises from financial incentives or the inherent difficulty of the field, 
but it undeniably prohibits many engineers from studying OS kernels and potentially gainning expertise.

This book presents what I have learned so far and explains the reasoning behind my approach. Following someone else's 
streamlined learning journey can enhance and accelerate your own understanding and help avoid common pitfalls.

That said, this book seeks to make OS development accessible to beginners while acknowledging and engaging with the 
field's inherent complexity.

\section{Why Write Your Own OS?}

Studying Operating Systems is challenging enough on its own but engineering one from the kernel upward adds vast layer of
complexity. Determining an initial approach to the subject can be challenging enough to discourage many beginners. 
Ultimately, diving into OS development requires a willingness to get your hands dirty and learn by doing.

The low-level nature of OS development guarantees that many obstacles will inevitably arise. 
Yet beyond the theoretical knowledge, the field offers a wealth of engineering skills to be acquired. 
From understanding how a bootloader works to uncovering how hardware orchestrates basic tasks-such as handling 
signals from peripheral devices or performing arithmetic-the amount to learn is limited only by your determination. 
By the time you finish this project, you will emerge as a fundamentally different person: a low-level developer-or 
perhaps even an engineer, dare I say.

\section{What You'll Learn}

\begin{itemize}
  \item Bootloader basics
  \item Transitioning from real mode to protected mode
  \item CPU operating modes
  \item Interrupts and the Interrupt Descriptor Table (IDT)
  \item Memory management and paging
  \item Process management and context switching
  \item User and kernel modes
\end{itemize}

\section{Who This Book Is For}

By now, it should be clear that the purpose of this book is to make diving into OS development a bit more-beginner friendly.
I write primarily from my own perspective as an Electrical Engineering and Computer Science student, and I imagine addressing 
readers with a similar technical background and level of knowledge.

Nevertheless, this project also aims to benefit engineers transitioning into the field, as well as professors seeking to 
incorporate OS kernel development into their courses. It doThat said, this book should bring OS development closer to beginners, but it does not shy away from the 
inherent complexity of the subject.
es so by highlighting the challenges students are likely to face 
and by providing a simple prototype that can be understood, replicated, or built upon.

\section{What You Should Already Know}

As was mentioned above, I had some technical background before entering the field.
Below you can find a brief summary of my experience at the time I started this project.

More specifically I had experience in:
\begin{itemize}
    \item High-level C programming
    \item Basic understanding of assembly
    \item Introductory digital design and computer architecture
    \item Theoretical understanding of operating systems
    \item Tools such as Git, Make and gcc
  \end{itemize}

\section{How To Approach This Book}

Most people approach complex subjects in fundamentally different ways. It should be clear that everyone 
will struggle in different areas, and this should never discourage you. Working through a structured 
resource can greatly help in overcoming those initial difficulties.

When-not if-times get tough, don't hesitate to reach out to me, a contributor, or one of your professors 
for help in clarifying misunderstandings.

\section{Book Structure and Approach}

This book follows the narrative of my own development journey. In each stage of building the operating 
system, I faced structural and architectural decisions. In the first chapters, I'll walk you through 
the reasoning behind my choices — from setting up a simple bootloader and transitioning from 16-bit to 
32-bit protected mode, to handling interrupts and implementing memory and process management. These early 
chapters emphasize on simplicity and clarity. After finishing the implementation of the designs decided we 
will explore more complex or alternative designs, compare architectures, and analyze the trade-offs they involve.