\chapter{Bootloader}

If you are stil here... buckle up. In this chapter we will familiarize ourselves with some concepts necessary to understand bootloaders
and then start writting our own.

Before we start it should be made clear that everything below applies to the Intel i-386 processor architecture (32-bit x86).
However, transferring that knowledge to different architectures should not be that difficult

\section{CPU Operating Modes}

When the computer turns on the x86 processor is automatically in \textbf{Real Mode}, which has some significant limitations. However,
it is kept even in newer processors for backwards compatibility reasons. 

When in Real Mode the CPU is running by default in 16-bit mode. While 32-bit registers are technically still available they 
should not be used, except when changing to Protected Mode (32-bit mode).

Another limitation of Real Mode is that you only have access to a specific size of memory. When referring to a memory 
address in Real Mode we use a 20-bit physical addressing. The Physical Address is referred to using a Segment and Offset like this: 
\[
\textbf{PA = Segment} \cdot \textbf{16 + Offset}
\]
Essentially, using this convention you can only represent a number if it can fit in a 5 digit hex. It is also apparent that
there are multiple ways to represent the same address. For example the physical address 0x12345 can be represented 
by 0x1234 and 0x0005, 0x1230 and 0x0045, 0x1200 and 0x0345... and so on. This way of addressing memory limits us to just 
below 1MiB of memory.

By now it should be clear that the addresses used in Real Mode are the actual physical addresses. This hinders us from protecting
memory and defining its owenership because every process can simply access all memory segments. We will get into virtual memory 
later on this book but I will give a brief explaination of how it helps with owenership just to clarify why physical 
addresses are limiting.

When having virtual addresses, our Operating System is responsible of mapping every virtual address to a physical onen.
When this mappning is done, the operating systems ensures that each program has its own range of physical addresses.
When two programs refer to the same virtual memory, very little does it matter, since the mapping will make sure they 
will refer to totally different physical addresses, rendering both unable to access eachothers' memory.

Having said that, Real Mode is simply inadequate for modern systems. This is why engineers came up with another CPU 
Operation Mode called \textbf{Protected Mode}. In this mode, while we still do not have any virtualization, we can 
take advantage of how memory is segmented to protect critical data from the user. This can happen by defining different 
memory segments with different privileges (ring levels) and letting the CPU decide if a piece of code has the privilages 
it tries to claim. This is decided according to the segment through which we are accessing that memory (we will se that in
practice). Memory management and CPU Operating Modes will have chapters of their own later in this book so we will not 
elaborate any longer here. For now let's focus on what a bootloader is and what it needs to do in its short but 
critical lifespan. 

\section{The Role Of The Bootloader}

When the computer turns on the first program to take control is the BIOS. Among other things, the BIOS transfers control to 
the bootloader which is then responsible for loading the OS. Modern systems use UEFI but in the sake of simplicity we 
will focus on BIOS.

First, the BIOS scans the data storage devices. More precisely it checks the first 512 bytes of each one, namely the Master Boot Record 
(MBR), which is the place a bootloader conventionally resides upon. If the last two bytes of the MBR are the word 0xAA55 the BIOS 
classifies the storage device as a bootable device.

Once the bootable is identified the BIOS loads the bootloader from the MBR to the memory address 0x7C00. This address has been
traditionally used by BIOS software to load the bootloader. Bootloader developers conventionally assume this is where their 
bootloader will is be loaded. The address 0x7C00 is way below the 1MiB accessible range and still leaves space below 
it for interrupt vectors (we will talk about them later).

After control has been passed to the bootloader it is now its job to load the rest of the operating systems. In later section we will 
discuss some techniques to overcome the 512-byte barrier and the limitations of the Real Mode. For now let's take a look in how
we can load the kernel.

\section{Loading The Kernel}

Let's start by dumping some code. Please do not be overwhelmed by it as we will explain it thoroughly shortly after.

\begin{lstlisting}[caption={Simple bootloader start in assembly}]
[ORG 0x7C00] ; This is where the bootloader is loaded in memory
[BITS 16]    ; Bootloader code starts in 16-bit mode

start:
    cli
    mov ax, 0x0700
    mov ss, ax       ; Set stack segment to 0x0700
    mov sp, 0x0000   ; Set stack pointer below of bootloader
    xor ax, ax       ; Zero-out ax
    mov ds, ax       ; Set data segment to 0
    mov es, ax       ; Set extra segment to 0

    mov ah, 0x02
    mov al, 1        ; Number of sectors
    mov ch, 0
    mov cl, 2
    mov dh, 0
    mov dl, 0x80
    mov bx, 0x1000    ; Segment
    mov es, bx
    xor bx, bx        ; Offset
    int 0x13
\end{lstlisting}
    
Let's analyze this line by line. 

First of all \texttt{cli} is used to prevent the system from triggering interrupts.
Since we have not dealt with setting up interrupt handling yet, they will just cause problems.

In lines 6 to 8 we are setting up a simple stack for our Real Mode. To understand these lines we must
remember how we address physical memory in Real Mode. It our Stack Segment pointer (ss) we choose segment 0x0700
and in our Stack Pointer (sp) we define the offset 0x0000. Now the physical address is calculated as such:
\[
\textbf{PA = 0x0700} \cdot \textbf{16 + 0x0000}
\textbf{ => PA = 0x7000 + 0x0000}
\textbf{    => PA = 0X7000}
\]
This address is chosen to be more than 512 bytes below 0x7C00, the range where out bootloader is placed.
Note that the bootloader might still run without lines 6 to 11, however, without having the stack set up
and the ax, ds and es registers zeroed-out the environment would be highly unpredictable.

Now that we are in a controllable environment we can load our kernel into memory. To do this we will must use
a very useful feature of BIOS, BIOS interrupts. Since we have not explained interrupts yet, we can think of them
as favors. More specifically when we trigger a BIOS interrupt we stop the execution of anything else, as the name states,
and have BIOS do what we ask. In this occasion by calling \texttt{int 0x13} we ask the BIOS to load some data from our
hard drive into our memory. However, before asking that we must pass some parameters using some registers to tell BIOS
exactly what it should do.

\begin{table}[h]
    \centering
    \begin{tabular}{|c|p{5cm}|p{4cm}|}
    \hline
    \textbf{Register} & \textbf{Purpose} & \textbf{Value Used} \\ \hline
    \texttt{AH} & BIOS function number & \texttt{0x02} (read sectors) \\ \hline
    \texttt{AL} & Number of sectors to read & \texttt{1} sectors \\ \hline
    \texttt{CH} & Cylinder number (part 1) & \texttt{0} \\ \hline
    \texttt{CL} & Sector number (bits 0–5) and high bits of cylinder (bits 6–7) & \texttt{2} (start at sector 2) \\ \hline
    \texttt{DH} & Head number & \texttt{0} \\ \hline
    \texttt{DL} & Drive number & \texttt{0x80} (first hard drive) \\ \hline
    \texttt{ES:BX} & Memory segment:offset where data is stored & \texttt{0x1000:0x0000} (i.e., \texttt{0x10000}) \\ \hline
    \end{tabular}
    \caption{INT 0x13, AH=0x02 — Disk Read BIOS Call Parameters}
    \label{tab:disk_read_params}
\end{table}
    
    

\begin{lstlisting}[caption={Assembly to load the kernel}]
    mov ah, 0x02
    mov al, 1        ; Number of sectors
    mov ch, 0
    mov cl, 2
    mov dh, 0
    mov dl, 0x80
    mov bx, 0x1000    ; Segment
    mov es, bx
    xor bx, bx        ; Offset
    int 0x13
\end{lstlisting}